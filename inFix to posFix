#pragma once
#include"stack.h"
#include"queue.h"
#include"BST.h"
#include<string>

using namespace std;

//Check operator!
bool isOperator(char x) {
	if (x == '+' || x == '-' || x == '*' || x == '/' || x == '^') return true; //is an operator
	return false;
}

//Return the priority of the operator
int checkPriority(char x) {
	if (x == '+' || x == '-') return 1;
	else if (x == '*' || x == '/') return 2;
	else if (x == '^') return 3;
	else return -1;
}

//Return a queue contain a postfix expression
functionQueue::queue<char> infixToPostfix(string s) {
	functionStack::stack<char> st;
	functionQueue::queue<char> q;
	st.init();
	q.init();
	int len = s.length();
	for (int i = 0; i < len; i++) {
		char c = s[i];
		if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9')){
			q.push(c);
		}
		else if (c == '(') {
			st.push(c);
		}
		else if (c == ')') {
			while (st.top->key != '(') {
				q.push(st.top->key);
				st.pop();
			}
			if (st.top != nullptr) {
				st.pop();
			}
		}
		else if(isOperator(c)) {
			while (!st.empty()
				&& checkPriority(c) <= checkPriority(st.top->key)) {
				q.push(st.top->key);
				st.pop();
			}
			st.push(c);
		}
	}

	while (!st.empty()) {
		q.push(st.top->key);
		st.pop();
	}
		return q;
	}
